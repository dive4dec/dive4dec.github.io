"use strict";(self.webpackChunkjupyterlab_filesystem_access=self.webpackChunkjupyterlab_filesystem_access||[]).push([[611],{611:(t,e,a)=>{a.r(e),a.d(e,{default:()=>y});var i=a(318),n=a(207),r=a(956),s=a(781),o=a(485),l=a(309),c=a(840);const d="FileSystem:";async function h(t){const e=[];for await(const a of t)e.push(a);return e}class w{constructor(){this._isDisposed=!1,this._fileChanged=new c.Signal(this),this._rootHandle=null}get isDisposed(){return this._isDisposed}dispose(){this.isDisposed||(this._isDisposed=!0,c.Signal.clearData(this))}get name(){return"FileSystem"}get serverSettings(){return o.ServerConnection.makeSettings()}get fileChanged(){return this._fileChanged}get rootHandle(){return this._rootHandle}set rootHandle(t){this._rootHandle=t}async get(t,e){if(t=this.cleanPath(t),!this._rootHandle)return{name:"",path:"",created:(new Date).toISOString(),last_modified:(new Date).toISOString(),format:null,mimetype:"",content:null,writable:!0,type:"directory"};const a=await this.getParentHandle(t),i=l.PathExt.dirname(t),n=l.PathExt.basename(t);let r;if(r=n?await this.getHandle(a,n):a,"file"===r.kind)return this.getFileModel(r,i,!0);{const t=[];for await(const e of r.values())"file"===e.kind?t.push(await this.getFileModel(e,l.PathExt.join(i,n))):t.push({name:e.name,path:l.PathExt.join(i,n,e.name),created:"",last_modified:"",format:null,mimetype:"",content:null,writable:!0,type:"directory"});return{name:n,path:l.PathExt.join(i,n),last_modified:"",created:"",format:null,mimetype:"",content:t,size:void 0,writable:!0,type:"directory"}}}getDownloadUrl(t){throw new Error("Method not implemented.")}async newUntitled(t){let e="";t&&t.path&&(e=this.cleanPath(t.path));const a=t?.type||"directory",i=l.PathExt.join(e,"directory"===a?"Untitled Folder":"untitled"),n=t?.ext||"txt",r=await this.getParentHandle(i);let s=l.PathExt.basename(i);const o=s;let c;if("directory"===a){let t=1;for(;await this.hasHandle(r,s);)s=`${o} ${t++}`;await r.getDirectoryHandle(s,{create:!0}),c=await this.get(l.PathExt.join(e,s))}else{let t=1;for(;await this.hasHandle(r,`${s}.${n}`);)s=`${o}${t++}`;const a=`${s}.${n}`;await r.getFileHandle(a,{create:!0}),c=await this.get(l.PathExt.join(e,a))}return this._fileChanged.emit({type:"new",oldValue:null,newValue:c}),c}async delete(t){t=this.cleanPath(t);const e=await this.getParentHandle(t);await e.removeEntry(l.PathExt.basename(t),{recursive:!0}),this._fileChanged.emit({type:"delete",oldValue:{path:t},newValue:null})}async rename(t,e){t=this.cleanPath(t),e=this.cleanPath(e),await this.doCopy(t,e),await this.delete(t);const a=this.get(e);return a.then((e=>{this._fileChanged.emit({type:"rename",oldValue:{path:t},newValue:e})})),a}async save(t,e){t=this.cleanPath(t);const a=await this.getParentHandle(t);if("directory"===e?.type)return await a.getDirectoryHandle(l.PathExt.basename(t),{create:!0}),this.get(t);const i=await a.getFileHandle(l.PathExt.basename(t),{create:!0}),n=await i.createWritable({}),r=e?.format,s=e?.content;if("json"===r){const t=JSON.stringify(s,null,2);await n.write(t)}else await n.write(s);return await n.close(),this.get(t)}async copy(t,e){t=this.cleanPath(t);const a=await this.get(t),i=l.PathExt.dirname(t);let n=a.name;if(i===e){const t=l.PathExt.extname(a.name);n=t?`${n.slice(0,n.length-t.length)} (Copy)${t}`:`${n} (Copy)`}const r=l.PathExt.join(e,n);return await this.doCopy(t,r),this.get(r)}async createCheckpoint(t){return{id:"test",last_modified:(new Date).toISOString()}}async listCheckpoints(t){return[{id:"test",last_modified:(new Date).toISOString()}]}restoreCheckpoint(t,e){return Promise.resolve(void 0)}deleteCheckpoint(t,e){return Promise.resolve(void 0)}async getParentHandle(t){const e=this._rootHandle;if(!e)throw new Error("No root file handle");let a=e;for(const e of t.split("/").slice(0,-1))a=await a.getDirectoryHandle(e);return a}async getHandle(t,e){const a=(await h(t.values())).filter((t=>t.name===e));if(a.length)return a[0];throw new Error(`${e} does not exist.`)}async hasHandle(t,e){const a=(await h(t.values())).filter((t=>t.name===e));return Boolean(a.length)}async getFileModel(t,e,a){const i=await t.getFile();let n,r=null;return n=i.type&&i.type.split("/")&&["image","audio","video"].includes(i.type.split("/")[0])?"base64":"text",a&&(r="base64"===n?function(t){let e="";const a=new Uint8Array(t);for(let t=0;t<a.byteLength;t++)e+=String.fromCharCode(a[t]);return window.btoa(e)}(await i.arrayBuffer()):await i.text()),{name:i.name,path:l.PathExt.join(e,i.name),created:new Date(i.lastModified).toISOString(),last_modified:new Date(i.lastModified).toISOString(),format:n,content:r,writable:!0,type:"file",mimetype:i.type}}async doCopy(t,e){const a=await this.getParentHandle(t),i=l.PathExt.basename(t);let n;n=i?await this.getHandle(a,i):a;const r=await this.getParentHandle(e),s=l.PathExt.basename(e);if("directory"===n.kind){await r.getDirectoryHandle(s,{create:!0});for await(const a of n.values())await this.doCopy(l.PathExt.join(t,a.name),l.PathExt.join(e,a.name))}else{const t=await r.getFileHandle(s,{create:!0}),e=await t.createWritable({}),a=await n.getFile(),i=await a.arrayBuffer();e.write(i),await e.close()}}cleanPath(t){return t.includes(d)?t.replace(d,""):t}}const y={id:"jupyterlab-filesystem-access:plugin",requires:[n.IFileBrowserFactory,r.ITranslator],autoStart:!0,activate:(t,e,a)=>{if(!window.showDirectoryPicker)return void console.warn("The File System Access API is not supported in this browser.");const{serviceManager:n}=t,{createFileBrowser:r}=e,o=a.load("jupyterlab-filesystem-access"),l=new w;n.contents.addDrive(l);const c=r("jp-filesystem-browser",{driveName:l.name,restore:!1});c.title.caption=o.__("Local File System"),c.title.icon=s.listIcon;const d=new i.ToolbarButton({icon:s.folderIcon,onClick:async()=>{const t=await window.showDirectoryPicker();t&&(l.rootHandle=t,c.model.cd("/"))},tooltip:o.__("Open a new folder")});c.toolbar.insertItem(0,"open-directory",d),t.shell.add(c,"left")}}}}]);